<!--
    Logic for Sensor/Asset Graphs, Datepicker, and Data Replay.

    This file contains the JavaScript logic required to render Vega-Lite charts, manage date selection,
    and handle data fetching for both Assets and Sensors.

    CONTEXT:
    - This file contains NO HTML structures. It is purely event handling and logic.
    - It is designed to be included in templates asset_graph.html and sensors/index.html.

    FUNCTIONALITIES:
    1. Graph Visualization: Renders the Vega-Lite chart tailored to the specific Asset or Sensor.
    2. Datepicker: Initializes the Litepicker with custom ranges (e.g., simulation ranges or simple "Last 7 days").
    3. State Management: Updates the URL with the selected date range for shareability.
    4. Data Fetching: Handles API calls to fetch chart data, KPIs, and annotations.
    5. Replay Mode: Logic for the chart/graph "Play/Pause/Stop" visualization of belief data.
    6. Customization: Handles logic for "sensors_to_show" legends and chart type switching.

    DEPENDENCIES:
    - Requires `flexmeasures` global object and Jinja2 variables (e.g., `asset.id`, `sensor.id`, `event_starts_after`).
-->
<script type="module" type="text/javascript">

    // Import local js (the FM version is used for cache-busting, causing the browser to fetch the updated version from the server)
    import { convertToCSV } from "{{ url_for('flexmeasures_ui.static', filename='js/data-utils.js') }}?v={{ flexmeasures_version }}";
    import { subtract, computeSimulationRanges, lastNMonths, encodeUrlQuery, getOffsetBetweenTimezonesForDate, toIsoStringWithOffset } from "{{ url_for('flexmeasures_ui.static', filename='js/daterange-utils.js') }}?v={{ flexmeasures_version }}";
    import { partition, updateBeliefs, beliefTimedelta, setAbortableTimeout } from "{{ url_for('flexmeasures_ui.static', filename='js/replay-utils.js') }}?v={{ flexmeasures_version }}";
    import { decompressChartData, checkDSTTransitions, checkSourceMasking } from "{{ url_for('flexmeasures_ui.static', filename='js/chart-data-utils.js') }}?v={{ flexmeasures_version }}";

    let picker;
    let vegaView;
    let previousResult;
    let previousPlaybackResult;
    let queryStartDate;
    let queryEndDate;
    let storeStartDate;
    let storeEndDate;
    {% if event_starts_after and event_ends_before %}
    storeStartDate = new Date('{{ event_starts_after }}');
    storeEndDate = new Date('{{ event_ends_before }}');
    checkDSTTransitions(storeStartDate, storeEndDate);
    {% endif %}
    let replaySpeed = 100
    let chartType = '{{ chart_type }}';  // initial chart type from session variable

    if ('{{ active_page }}' == 'assets') {
        chartType = 'chart_for_multiple_sensors'
    }
    // Update chart type picker: active state, reload data event
    document.addEventListener('DOMContentLoaded', function () {
        var dropdownItems = document.querySelectorAll('#chart-type-picker .dropdown-item');
        for (var i = 0; i < dropdownItems.length; i++) {

            // Set initial chart type
            if (dropdownItems[i].getAttribute('data-chart-type') === chartType) {
                dropdownItems[i].classList.add('active');
            }

            // Add event listener
            dropdownItems[i].addEventListener('click', function (e) {
                e.preventDefault();
                chartType = this.getAttribute('data-chart-type');

                // Update the active state of the dropdown items
                var dropdownItems = document.querySelectorAll('.dropdown-item');
                dropdownItems.forEach(item => {
                    if (item === this) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });

                // Reload daterange
                embedAndLoad(chartSpecsPath + 'event_starts_after=' + storeStartDate.toISOString() + '&event_ends_before=' + storeEndDate.toISOString() + '&', elementId, datasetName, previousResult, storeStartDate, storeEndDate)
                vegaView.change(datasetName, vega.changeset().remove(vega.truthy).insert(previousResult.data)).resize().run();
            });
        }
    });

    async function embedAndLoad(chartSpecsPath, elementId, datasetName, previousResult, startDate, endDate) {
        const url = encodeUrlQuery(chartSpecsPath + 'dataset_name=' + datasetName + '&combine_legend=' + combineLegend + '&width=container&include_sensor_annotations=false&include_asset_annotations=false&chart_type=' + chartType);
        await vegaEmbed('#' + elementId, url, {{ chart_options | safe }})
      .then(function (result) {

            // Create a custom menu item for exporting to CSV
            const exportToCSVAction = document.createElement('a');
            exportToCSVAction.id = 'exportToCSVAction';
            exportToCSVAction.href = '#';
            exportToCSVAction.download = datasetName + '.csv';
            exportToCSVAction.textContent = 'Save as CSV';
            exportToCSVAction.addEventListener('mousedown', async function (event) {
                event.preventDefault();
                const chartData = vegaView.data(datasetName);
                const csvContent = convertToCSV(chartData);
                const encodedUri = encodeURI(csvContent);
                exportToCSVAction.href = encodedUri;
            });

            // Append menu item to chart actions (hamburger menu)
            const vegaActions = document.querySelector('.vega-actions');
            if (vegaActions) {
                vegaActions.appendChild(exportToCSVAction);
            } else {
                console.log('Warning: CSV export functionality is not available, because no div with class=vega-actions was found to append export action to');
            }

            // result.view is the Vega View, chartSpecsPath is the original Vega-Lite specification
            vegaView = result.view;
            if (previousResult) {
                checkSourceMasking(previousResult.data);
                var slicedPreviousData = previousResult.data.filter(item => {
                    return item.event_start >= startDate.getTime() && item.event_start < endDate.getTime();
                })
                vegaView.change(datasetName, vega.changeset().remove(vega.truthy).insert(slicedPreviousData)).resize().run();
            }
        });
  }

    {% if active_page == "sensors" and user_can_update_sensor %}
    let upload = document.querySelector('#submitUpload');
    let uploadSpinner = document.querySelector("#spinner-upload-sensor-data");
    upload.addEventListener('click', function (e) {
        upload.classList.add('d-none');
        uploadSpinner.classList.remove('d-none');
        var formData = new FormData(document.getElementById('uploadForm'));
        fetch(apiBasePath + '/api/v3_0/sensors/' + {{ sensor.id }} + '/data/upload', {
        method: 'POST',
        body: formData,
    })
        .then(async function (response) {
            if (response.ok) {
                const data = await response.json();
                showToast(data.message, "success");
                // Update date range
                picker.setDateRange(
                    storeStartDate,
                    subtract(storeEndDate, 1),
                );
                uploadSpinner.classList.add('d-none');
                upload.classList.remove('d-none');
            } else {
                const data = await response.json();
                if (data.message.path_and_files === undefined) {
                    showToast(data.message, "error");
                }
                else {
                    for (const [key, value] of Object.entries(data.message.path_and_files)) {
                        if (typeof value === 'string') {
                            showToast(value, "error");
                        } else if (Array.isArray(value)) {
                            value.forEach(element => {
                                showToast(element, "error");
                            });
                        } else if (typeof value === 'object' && value !== null) {
                            Object.values(value).forEach(element => {
                                if (Array.isArray(element)) {
                                    element.forEach(item => showToast(item, "error"));
                                } else {
                                    showToast(element, "error");
                                }
                            });
                        } else {
                            // fallback for unexpected types
                            showToast(String(value), "error");
                        }
                    }
                }
                uploadSpinner.classList.add('d-none');
                upload.classList.remove('d-none');
            }
        })
        .catch(function (error) {
            // Network or unexpected error
            console.error("Upload error:", error);
            showToast("An error occurred: " + error.message, "error");
            uploadSpinner.classList.add('d-none');
            upload.classList.remove('d-none');
        });
      });
    {% endif %}


    // event listener to refresh graph
    document.addEventListener('sensorsToShowUpdated', async function () {
        await embedAndLoad(chartSpecsPath + 'event_starts_after=' + storeStartDate.toISOString() + '&event_ends_before=' + storeEndDate.toISOString() + '&', elementId, datasetName, previousResult, storeStartDate, storeEndDate);
    })

    var combineLegend = 'true';
    {% if active_page == "assets" %}
    var dataPath = '/api/v3_0/assets/' + {{ asset.id }};
    var dataDevPath = '/api/dev/asset/' + {{ asset.id }};
    var datasetName = 'asset_' + {{ asset.id }};
    {% set total_sensors = asset.sensors_to_show | map(attribute = 'sensors') | map('length') | sum %}
    {% if total_sensors > 7 %}
    {% if session.get("keep_legends_below_graphs") %}
    combineLegend = 'true';
    {% else %}
    combineLegend = 'false';
    {% endif %}
    {% else %}
    {% if not session.get("keep_legends_below_graphs") %}
    combineLegend = 'true';
    {% endif %}
    {% endif %}
    {% elif active_page == "sensors" %}
    var dataPath = '/api/dev/sensor/' + {{ sensor.id }};
    var dataDevPath = '/api/dev/sensor/' + {{ sensor.id }};
    var datasetName = 'sensor_' + {{ sensor.id }};
    {% endif %}
    var elementId = 'sensorchart';
    var chartSpecsPath = dataPath + '/chart?';

    // Set up abort controller to cancel requests
    var controller = new AbortController();
    var signal = controller.signal;

    var playBackDataLoadedForKnownDateRange = false;

    // Set session start and end
    {% if event_starts_after and event_ends_before %}
    var sessionStart = new Date('{{ event_starts_after }}');
    var sessionEnd = new Date('{{ event_ends_before }}');
    sessionEnd.setSeconds(sessionEnd.getSeconds() - 1); // -1 second in case most recent event ends at midnight
    sessionStart.setHours(0, 0, 0, 0); // get start of first day
    sessionEnd.setHours(0, 0, 0, 0); // get start of last day
    {% else %}
    var sessionStart = null
    var sessionEnd = null
    {% endif %}


    // Create date range picker and the logic for a new date range selection (mostly, fetching data and displaying the chart for it)
    const date = Date();
    {% if active_page == "sensors" and sensor.event_resolution.days > 0 %}
    const minRes = "day"
    {% else %}
    const minRes = "hour"
    {% endif %}

    function createPicker(startDate, endDate, customRanges) {

        picker = new Litepicker({
            element: document.getElementById('datepicker'),
            plugins: ['ranges', 'keyboardnav'],
            ranges: {
                customRanges: customRanges,
                position: 'top'
            },
            autoRefresh: true,
            moduleRanges: true,
            showWeekNumbers: true,
            numberOfMonths: 1,
            numberOfColumns: 1,
            inlineMode: true,
            switchingMonths: 1,
            singleMode: false,
            startDate: startDate,
            endDate: endDate,
            dropdowns: {
                years: true,
                months: true,
            },
            format: 'YYYY-MM-DD\\T00:00:00',
        });
        picker.on('selected', (startDate, endDate) => {
            startDate = startDate.toJSDate();
            endDate = endDate.toJSDate();

            {% if FLEXMEASURES_MODE == "play" %}
            // Update daterange buttons on simulation servers (only replacing the entire picker works)
            picker.destroy();
            customRanges = computeSimulationRanges(startDate, endDate, minRes);
            picker = createPicker(startDate, endDate, customRanges);
            {% endif %}

            endDate.setDate(endDate.getDate() + 1);

            // Update current url without reloading the page
            var base_url = window.location.href.split("?")[0];
            var new_url = `${base_url}?start_time=${toIsoString(startDate)}&end_time=${toIsoString(endDate)}`;
            window.history.pushState({}, null, new_url);

            storeStartDate = startDate;
            storeEndDate = endDate;
            var queryStartDate = (startDate != null) ? (startDate.toISOString()) : (null);
            var queryEndDate = (endDate != null) ? (endDate.toISOString()) : (null);

            {% if active_page == "sensors" %}
            const toggleStats = document.getElementById('toggleStatsCheckbox');
            if (toggleStats.checked) {
                loadSensorStats({{ sensor.id }}, storeStartDate.toISOString(), storeEndDate.toISOString());
    }
              else {
        loadSensorStats({{ sensor.id }});
              }
    {% endif %}

    stopReplay()

    $("#spinner").show();
    checkDSTTransitions(startDate, endDate)
    Promise.all([
        fetchGraphDataAndKPIs(previousResult, startDate, endDate, queryStartDate, queryEndDate),
        /**
        // Fetch annotations
        fetch(dataPath + '/chart_annotations?event_starts_after=' + queryStartDate + '&event_ends_before=' + queryEndDate, {
            method: "GET",
            headers: {"Content-Type": "application/json"},
            signal: signal,
        })
        .then(function(response) { return response.json(); }),
        */

        // Embed chart
        embedAndLoad(chartSpecsPath + 'event_starts_after=' + queryStartDate + '&event_ends_before=' + queryEndDate + '&', elementId, datasetName, previousResult, startDate, endDate),
    ]).then(function (result) {
        $("#spinner").hide();
        vegaView.change(datasetName, vega.changeset().remove(vega.truthy).insert(result[0])).resize().run();
        previousResult = {
            start: startDate,
            end: endDate,
            data: result[0]
        };
        checkSourceMasking(previousResult.data);
        playBackDataLoadedForKnownDateRange = false;
        /**
        vegaView.change(datasetName + '_annotations', vega.changeset().remove(vega.truthy).insert(result[1])).resize().run();
        */
    }).catch(console.error);
      });
    return picker
  }
    {% if FLEXMEASURES_MODE == "play" %}
    const customRanges = computeSimulationRanges(sessionStart, sessionEnd, minRes);
    {% else %}
    const customRanges = {
        'Last 7 days': [subtract(date, 6), new Date(date)],
        'Today and tomorrow': [subtract(date, -1), new Date(date)]
    };
    {% endif %}
    picker = createPicker(sessionStart, sessionEnd, customRanges);

    {% if active_page == "sensors" %}
    // Call loadSensorStats if the toggleStatsCheckbox checkbox is checked or unchecked
    document.getElementById('toggleStatsCheckbox').addEventListener('change', function () {
        if (this.checked) {
            loadSensorStats({{ sensor.id }}, storeStartDate.toISOString(), storeEndDate.toISOString());
          }
          else {
        loadSensorStats({{ sensor.id }});
          }
      });
    {% endif %}


    /** If the page is done loading, get data (for the time range stored in the session, or the default range),
     * check for time zone differences, and then trigger the time range picker to display the correct range.
     */
    document.onreadystatechange = async () => {
        if (document.readyState === 'complete') {
            {% if event_starts_after and event_ends_before %}
            // Initialize picker to the date selection specified in the session
            $("#spinner").show();
            {% if active_subpage == "asset_graph" and has_kpis %}
            getAssetKPIs();
            {% endif %}
            const initialData = fetch(dataPath + '/chart_data?event_starts_after=' + '{{ event_starts_after }}' + '&event_ends_before=' + '{{ event_ends_before }}' + '&compress_json=true', {
                method: "GET",
                headers: { "Content-Type": "application/json" },
                signal: signal,
            })
                .then(function (response) { return response.json(); })
                .then(data => decompressChartData(data));
            let fetchedInitialData = await Promise.all([
                initialData,
                embedAndLoad(chartSpecsPath + 'event_starts_after=' + '{{ event_starts_after }}' + '&event_ends_before=' + '{{ event_ends_before }}' + '&', elementId, datasetName, previousResult, sessionStart, sessionEnd),
            ]).then(function (result) { return result[0] }).catch(console.error);
            $("#spinner").hide();
            vegaView.change(datasetName, vega.changeset().remove(vega.truthy).insert(fetchedInitialData)).resize().run();
            var sessionStart = new Date('{{ event_starts_after }}');
            var sessionEnd = new Date('{{ event_ends_before }}');
            previousResult = {
                start: sessionStart,
                end: sessionEnd,
                data: fetchedInitialData
            };
            checkSourceMasking(previousResult.data);
            var timerangeNotSetYet = false
            {% else %}
            var timerangeNotSetYet = true
            {% endif %}
            fetch(dataDevPath, {
                method: "GET",
                headers: { "Content-Type": "application/json" },
            })
                .then(function (response) { return response.json(); })
                .then(function (data) {
                    var offsetDifference = getOffsetBetweenTimezonesForDate(new Date(), data.timezone, jstz.determine().name());
                    if (offsetDifference != 0) {
                        var offsetNotice = (offsetDifference > 0) ? 'which is currently ahead by ' + offsetDifference + ' minutes' : 'which is currently behind by ' + offsetDifference + ' minutes';
                        showToast('Please note that the sensor data you are viewing is located in a different timezone (' + offsetNotice + ').<br/>To view the data from a local perspective, set your locale timezone to ' + data.timezone + '.');
                    }
                    {% if active_page == "assets" %}
                    var timerangeVar = 'timerange_of_sensors_to_show';
                    {% else %}
                    var timerangeVar = 'timerange';
                    {% endif %}

                    if (timerangeVar in data) {
                        var start = new Date(data[timerangeVar].start);
                        var end = new Date(data[timerangeVar].end);
                        end.setSeconds(end.getSeconds() - 1); // -1 second in case most recent event ends at midnight
                        start.setHours(0, 0, 0, 0); // get start of first day
                        end.setHours(0, 0, 0, 0); // get start of last day

                        {% if active_page == "assets" %}
                        var timerangeVar = 'timerange_of_sensors_to_show';
                        {% else %}
                        var timerangeVar = 'timerange';
                        {% endif %}

                        // Detect if URL already specifies a range
                        const urlParams = new URLSearchParams(window.location.search);
                        const urlStartTimeRaw = urlParams.get('start_time');
                        const urlEndTimeRaw = urlParams.get('end_time');
                        const urlHasRange = urlStartTimeRaw && urlEndTimeRaw;

                        picker.setOptions({
                            dropdowns: {
                                minYear: start.getFullYear(),
                                maxYear: end.getFullYear(),
                            },
                        });

                        if (urlHasRange) {
                            const urlStartTime = urlStartTimeRaw.replace(' ', '+');
                            const urlEndTime = urlEndTimeRaw.replace(' ', '+');

                            const urlStartDate = new Date(urlStartTime);
                            const urlEndDateExclusive = new Date(urlEndTime);

                            if (!isNaN(urlStartDate) && !isNaN(urlEndDateExclusive)) {
                                // picker end date is inclusive â†’ subtract 1 day
                                urlEndDateExclusive.setDate(urlEndDateExclusive.getDate() - 1);

                                // This fires the 'selected' event and load graphs
                                picker.setDateRange(urlStartDate, urlEndDateExclusive);
                                picker.gotoDate(urlEndDateExclusive);
                            }
                        } else {
                            // Original behaviour when there is no URL range

                            if (timerangeNotSetYet) {
                                // Initialize picker to the last 2 days of sensor data
                                var nearEnd = new Date(end);
                                nearEnd.setDate(nearEnd.getDate() - 2);
                                var new_start_date = nearEnd;
                                var new_end_date = end;
                            } else {
                                var new_start_date = new Date('{{ event_starts_after }}');
                                var new_end_date = new Date('{{ event_ends_before }}');
                            }

                            // Persist the range on the datepicker UI so correct range is shown when the user opens the datepicker
                            new_end_date.setDate(new_end_date.getDate() - 1); // inclusive picker end
                            picker.setDateRange(new_start_date, new_end_date);
                            picker.gotoDate(new_end_date);
                        }
                    }


                });
        }
    };

    // Set up play/pause button for replay, incl. the complete replay logic
    let toggle = document.querySelector('#replay');
    toggle.addEventListener('click', function (e) {
        e.preventDefault();
        toggleReplay();
    });

    window.addEventListener('keypress', function (e) {
        // Do nothing if typing in an input field or textarea
        if (e.target.tagName.toLowerCase() === 'input' || e.target.tagName.toLowerCase() === 'textarea') {
            return;
        }
        // Start/pause/resume replay with 'p'
        if (e.key === 'p') {
            toggleReplay();
        } else if (e.key === 's') {
            stopReplay();
        }
    }, false);

    function toggleReplay() {
        if (toggle.classList.contains('stopped')) {
            startReplay();
        } else if (toggle.classList.contains('playing')) {
            pauseReplay();
        } else {
            resumeReplay();
        }
    }
    function pauseReplay() {
        toggle.classList.remove('playing');
        toggle.classList.add('paused');
    }
    function resumeReplay() {
        toggle.classList.remove('paused');
        toggle.classList.add('playing');
    }
    async function stopReplay() {
        if (toggle.classList.contains('stopped')) {
            return;
        }
        toggle.classList.remove('playing');
        toggle.classList.remove('paused');
        toggle.classList.add('stopped');

        // Abort previous request and create abort controller for new request
        controller.abort();
        controller = new AbortController();
        signal = controller.signal;

        // Remove replay ruler and replay time
        vegaView.change('replay', vega.changeset().remove(vega.truthy).insert({ 'belief_time': null })).run().finalize();
        document.getElementById('replay-time').innerHTML = '';

        // Show previous results
        $("#spinner").show();
        await embedAndLoad(chartSpecsPath + 'event_starts_after=' + storeStartDate.toISOString() + '&event_ends_before=' + storeEndDate.toISOString() + '&', elementId, datasetName, previousResult, storeStartDate, storeEndDate);
        $("#spinner").hide();
    }
    function startReplay() {
        toggle.classList.remove('stopped');
        toggle.classList.add('playing');
        var beliefTime = new Date(storeStartDate);
        var numReplaySteps = Math.ceil((storeEndDate - storeStartDate) / beliefTimedelta);
        queryStartDate = (storeStartDate != null) ? (storeStartDate.toISOString()) : (null);
        queryEndDate = (storeEndDate != null) ? (storeEndDate.toISOString()) : (null);
        const spinner = document.getElementById('spinner');
        if (!playBackDataLoadedForKnownDateRange) {
            spinner.hidden = false;
            spinner.style.display = 'block';
        }
        Promise.all([
            playBackDataLoadedForKnownDateRange ? Promise.resolve(previousPlaybackResult) :
                // Fetch time series data (all data, not only the most recent beliefs)
                fetch(dataPath + '/chart_data?event_starts_after=' + queryStartDate + '&event_ends_before=' + queryEndDate + '&most_recent_beliefs_only=false&compress_json=true', {
                    method: "GET",
                    headers: { "Content-Type": "application/json" },
                    signal: signal,
                })
                    .then(function (response) { return response.json(); })
                    .then(data => decompressChartData(data)),
        ]).then(function (result) {
            previousPlaybackResult = result[0];
            replayBeliefsData(result[0]);
            playBackDataLoadedForKnownDateRange = true;
        }).catch(console.error)
            .finally(function () {
                spinner.hidden = true;
                spinner.style.display = 'none';
            });


        const timer = ms => new Promise(res => setAbortableTimeout(res, Math.max(ms, 0), signal));

        /**
         * Replays beliefs data.
         *
         * As we go forward in time in steps, replayedData is updated with newData that was known at beliefTime,
         * by splitting off newData from remainingData.
         * Then, replayedData is loaded into the chart.
         *
         * @param {Array} remainingData Array containing beliefs.
         */
        async function replayBeliefsData(remainingData) {
            var replayedData = [];
            for (var beliefTime = new Date(storeStartDate); beliefTime <= storeEndDate; beliefTime = new Date(beliefTime.getTime() + beliefTimedelta)) {
                while (document.getElementById('replay').classList.contains('paused')) {
                    await timer(1000);
                }
                if (document.getElementById('replay').classList.contains('stopped')) {
                    break;
                }
                var s = performance.now();

                // Split off one replay step of new data from the remaining data
                var newData;
                [newData, remainingData] = partition(
                    remainingData,
                    (item) => item.belief_time <= beliefTime.getTime(),
                );

                // Update beliefs in the replayed data given the new data
                replayedData = updateBeliefs(replayedData, newData);

                /** When selecting a longer time periode (more than a week), the replay slows down a bit. This
                 * seems to be mainly from reloading the data into the graph. Slicing the data takes 10-30 ms, and
                 * loading that data into the graph takes 30-200 ms, depending on how much data is shown in the
                 * graph. After trying different approaches, we fell back to the original approach of telling vega
                 * to remove all previous data and to insert a completely new dataset at each iteration. Updating
                 * the view with removing only a few data points (representing obsolete beliefs) and inserting only
                 * a few data points (representing the most recent new beliefs) actually made it slower.
                 */
                vegaView.change(datasetName, vega.changeset().remove(vega.truthy).insert(replayedData));
                vegaView.change('replay', vega.changeset().remove(vega.truthy).insert({ 'belief_time': beliefTime }));
                vegaView.run().finalize();

                document.getElementById('replay-time').innerHTML = beliefTime;

                // Approximate constant speed
                var e = performance.now();
                var throttle = e - s;
                await timer(replaySpeed - throttle);
            }

            // Stop replay when finished
            stopReplay()
        }
    }

    /**
     * Fetches data for the graph and KPIs, either from a previous result (if the date range is the same)
     * or from the API (if the date range is different).
     *
     * The previous result is used to avoid fetching the same data twice when the user goes back and forth
     * between different date ranges.
     *
     * If the date range changes, the function fetches the data from the API and also triggers an update
     * of the asset KPIs if the active subpage is the asset graph.
     *
     * @param {Object} previousResult The previous result, containing the start and end dates and the data.
     * @param {Date} startDate The start date for the new data.
     * @param {Date} endDate The end date for the new data.
     * @param {String} queryStartDate The start date as a string in ISO format, to be used in the query.
     * @param {String} queryEndDate The end date as a string in ISO format, to be used in the query.
     * @return {Promise} A promise that resolves with the data.
     */
    function fetchGraphDataAndKPIs(previousResult, startDate, endDate, queryStartDate, queryEndDate) {
        if (previousResult && previousResult.start.getTime() === startDate.getTime() && previousResult.end.getTime() === endDate.getTime()) {
            return Promise.resolve(previousResult.data);
        } else {
            {% if active_subpage == "asset_graph" and has_kpis %}
            getAssetKPIs();
            {% endif %}
            return fetch(dataPath + '/chart_data?event_starts_after=' + queryStartDate + '&event_ends_before=' + queryEndDate + '&compress_json=true', {
                method: "GET",
                headers: { "Content-Type": "application/json" },
                signal: signal,
            })
                .then(response => response.json())
                .then(data => decompressChartData(data));
        }
    }

    function getAssetKPIs() {
        const pickerStartDate = picker.getStartDate().toJSDate();
        const start = encodeURIComponent(toIsoStringWithOffset(pickerStartDate));
        var endDate = picker.getEndDate();
        endDate.setDate(endDate.getDate() + 1);
        endDate = encodeURIComponent(toIsoStringWithOffset(endDate.toJSDate()));
        const kpiCards = document.querySelector('#kpi-cards');
        return fetch('/api/v3_0/assets/{{ asset.id }}/kpis?start=' + start + '&end=' + endDate, {
            method: 'GET',
            headers: {
                "Content-Type": "application/json",
            },
        })
            .then(response => response.json())
            .then(response => {

                // Create card for each KPI object
                const data = response.data;
                // Set kpiCards to empty
                kpiCards.innerHTML = '';
                data.forEach(kpi => {
                    const link = document.createElement('a');
                    link.href = `${apiBasePath}/sensors/${kpi.sensor}`;
                    link.title = "See underlying KPI data";
                    link.classList.add('text-decoration-none', 'd-flex', 'flex-fill');

                    const colDiv = document.createElement('div');
                    colDiv.classList.add('col-md-3');
                    colDiv.classList.add('d-flex');
                    const card = document.createElement('div');
                    card.classList.add('card', 'flex-fill');
                    // Add sensor data to the card
                    const labelMap = {
                        'mean': 'Average',
                        'sum': 'Total',
                        'min': 'Min',
                        'max': 'Max'
                    };
                    const label = labelMap[kpi.downsample_function];
                    card.innerHTML = `
                  <div class="card-body d-flex flex-column justify-content-between">
                      <h5 class="card-title">${kpi.title}</h5>
                      <h5 class="card-text">
                          <strong>
                              ${label}: ${kpi.downsample_value} ${kpi.unit}
                          </strong>
                      </h5>
                  </div>
              `;
                    link.appendChild(card);
                    colDiv.appendChild(link);
                    kpiCards.appendChild(colDiv);
                });
            })
            .catch(error => {
                console.error('Error:', error);
                return []; // Return an empty array if there's an error
            });
    }

</script>