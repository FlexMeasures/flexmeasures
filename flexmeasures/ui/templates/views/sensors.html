{% extends "base.html" %}

{% set active_page = "sensors" %}

{% block title %} Sensor data {% endblock %}

{% block divs %}

      <div class="sensor-data charts text-center">
          <div class="row"><div class="alert alert-info" id="tzwarn" style="display:none;"></div></div>
          <div class="row on-top-md">
              <div class="col-sm-2">
                  <div class="sidepanel-container">
                      <div class="left-sidepanel-label">Select dates</div>
                      <div class="sidepanel left-sidepanel">
                          <div id="datepicker"></div>
                      </div>
                  </div>
              </div>
              <div class="col-sm-8">
                  <div id="sensorchart" class="card" style="width: 100%;"></div>
                  <div id="spinner" hidden="hidden">
                      <i class="fa fa-spinner fa-pulse fa-3x fa-fw"></i>
                      <span class="sr-only">Loading...</span>
                  </div>
              </div>
              <div class="col-sm-2">
                  <div class="replay-container">
                    <div id="replay"></div>
                    <div id="replay-time"></div>
                  </div>
              </div>
          </div>
          <hr>
      </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstimezonedetect/1.0.7/jstz.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/litepicker/dist/litepicker.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/litepicker/dist/plugins/ranges.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/litepicker/dist/plugins/keyboardnav.js"></script>

    <!-- Render Charts -->
    <script type="module" type="text/javascript">

      import { subtract, thisMonth, lastNMonths, getOffsetBetweenTimezonesForDate } from "{{ url_for('flexmeasures_ui.static', filename='js/daterange-utils.js') }}";

      let vegaView;
      let previousResult;
      let queryStartDate;
      let queryEndDate;
      let storeStartDate;
      let storeEndDate;

      function updateBeliefs(oldBeliefs, newBeliefs) {
        // Update oldBeliefs with the most recent newBeliefs about the same event by the same source

        // Group by event start and source
        var oldBeliefsByEventBySource = Object.fromEntries(new Map(oldBeliefs.map(belief => [belief['event_start'] + '_' + belief['source'].id, belief])));  // array -> dict (already had one belief per event)

        // Group by event start and source and select only the most recent new beliefs
        var mostRecentNewBeliefsByEventBySource = Object.fromEntries(new Map(newBeliefs.map(belief => [belief['event_start'] + '_' + belief['source'].id, belief])));  // array -> dict (assumes beliefs are ordered by ascending belief time, with the last belief used as dict value)

        /**
        // Group by event start and source
        const groupByEventStartAndSource = (beliefs) => {
          // Group beliefs by event_start and source, accumulates a dictionary using event_start and source.id as keys, and arrays of beliefs as values

          return beliefs.reduce((beliefsByEvent, currentBelief) => {
            let groupKey = currentBelief['event_start'] + '_' + currentBelief['source'].id;

            // Initialize new dict entry if the event_start is new
            if (!beliefsByEvent[groupKey]) {
              beliefsByEvent[groupKey] = [];
            }

            // Push the current belief into the group
            beliefsByEvent[groupKey].push(currentBelief);

            return beliefsByEvent;
          }, {});
        };
        var newBeliefsByEventBySource = groupByEventStartAndSource(newBeliefs);  // array -> dict (possibly multiple beliefs per event)

        // Select only the most recent new beliefs
        var mostRecentNewBeliefsByEventBySource = {};
        Object.entries(newBeliefsByEventBySource).forEach(
            ([event_start_and_source, newBeliefs]) => {
                let mostRecentNewBelief = newBeliefs.reduce((l, e) => e.belief_time > l.belief_time ? e : l);
                mostRecentNewBeliefsByEventBySource[event_start_and_source] = mostRecentNewBelief;
            }
        )
        **/

        // Return old beliefs updated with most recent new beliefs
        return Object.values({...oldBeliefsByEventBySource, ...mostRecentNewBeliefsByEventBySource})  // dict -> list
    }

      function partition(array, callback){
        return array.reduce(function(result, element, i) {
          callback(element, i, array)
            ? result[0].push(element)
            : result[1].push(element);

              return result;
            }, [[],[]]
          );
       };

      async function embedAndLoad(chartSpecsPath, elementId, datasetName, previousResult, startDate, endDate) {

        await vegaEmbed('#'+elementId, chartSpecsPath + 'dataset_name=' + datasetName + '&width=container&include_sensor_annotations=true&include_asset_annotations=true', {{ chart_options | safe }})
        .then(function (result) {
          // result.view is the Vega View, chartSpecsPath is the original Vega-Lite specification
          vegaView = result.view;
          if (previousResult) {
            var slicedPreviousResult = previousResult.filter(item => {
              return item.event_start >= startDate.getTime() && item.event_start < endDate.getTime()
            })
            vegaView.change(datasetName, vega.changeset().remove(vega.truthy).insert(slicedPreviousResult)).resize().run();
          }
        });
      }

      var sensorId = {{ sensor_id }}
      var sensorPath = '/api/dev/sensor/' + sensorId
      var chartSpecsPath = sensorPath + '/chart?'
      var elementId = 'sensorchart'
      var datasetName = 'sensor_' + sensorId

      // Set up abort controller to cancel requests
      var controller = new AbortController()
      var signal = controller.signal

      // Set up abort controller to cancel requests
      var controller = new AbortController()
      var signal = controller.signal

      const date = Date();
      const picker = new Litepicker({
          element: document.getElementById('datepicker'),
          plugins: ['ranges', 'keyboardnav'],
          ranges: {
              customRanges: {
                  'Today': [new Date(date), new Date(date)],
                  'Last 7 days': [subtract(date, 6), new Date(date)],
                  'This month': thisMonth(date)
              },
              position: 'bottom'
          },
          autoRefresh: true,
          moduleRanges: true,
          showWeekNumbers: true,
          numberOfMonths: 1,
          numberOfColumns: 1,
          inlineMode: true,
          switchingMonths: 1,
          singleMode: false,
          dropdowns: {
              years: true,
              months: true,
          },
          format: 'YYYY-MM-DD\\T00:00:00',
      });
      picker.on('selected', (startDate, endDate) => {

          // Stop replay
          let toggle = document.querySelector('#replay')
          toggle.classList.remove('playing');
          toggle.classList.remove('paused');
          toggle.classList.add('stopped');

          startDate = startDate.toJSDate()
          endDate = endDate.toJSDate()
          endDate.setDate(endDate.getDate() + 1);
          storeStartDate = startDate
          storeEndDate = endDate
          queryStartDate = (startDate != null) ? (startDate.toISOString()) : (null)
          queryEndDate = (endDate != null) ? (endDate.toISOString()) : (null)

          // Abort previous request and create abort controller for new request
          controller.abort()
          controller = new AbortController()
          signal = controller.signal

          $("#spinner").show();
          embedAndLoad(chartSpecsPath + 'event_starts_after=' + queryStartDate + '&event_ends_before=' + queryEndDate + '&', elementId, datasetName, previousResult, startDate, endDate);
          Promise.all([
              // Fetch time series data
              fetch(sensorPath + '/chart_data/?event_starts_after=' + queryStartDate + '&event_ends_before=' + queryEndDate, {
                  method: "GET",
                  headers: {"Content-Type": "application/json"},
              })
              .then(function(response) { return response.json(); }),

              // Fetch annotations
              fetch(sensorPath + '/chart_annotations/?event_starts_after=' + queryStartDate + '&event_ends_before=' + queryEndDate, {
                  method: "GET",
                  headers: {"Content-Type": "application/json"},
              })
              .then(function(response) { return response.json(); })
          ]).then(function(result) {
                $("#spinner").hide();
                vegaView.change(datasetName, vega.changeset().remove(vega.truthy).insert(result[0])).resize().run();
                vegaView.change(datasetName + '_annotations', vega.changeset().remove(vega.truthy).insert(result[1])).resize().run();
                previousResult = result[0];
          }).catch(console.error);
      });

      document.onreadystatechange = () => {
        if (document.readyState === 'complete') {
          fetch(sensorPath, {
            method: "GET",
            headers: {"Content-Type": "application/json"},
          })
          .then(function(response) { return response.json(); })
          .then(function(data) {
            var offsetDifference = getOffsetBetweenTimezonesForDate(new Date(), data.timezone, jstz.determine().name());
            if (offsetDifference != 0) {
              document.getElementById('tzwarn').style.display = 'block';
              var offsetNotice = (offsetDifference > 0) ? 'which is currently ahead by ' + offsetDifference + 'minutes' : 'which is currently behind by ' + offsetDifference + ' minutes'
              document.getElementById('tzwarn').innerHTML = 'Please note that the sensor data you are viewing is located in a different timezone (' + offsetNotice + ').<br/>To view the data from a local perspective, set your locale timezone to ' + data.timezone + '.'
            }
            if ('timerange' in data) {
              var start = new Date(data.timerange.start);
              var end = new Date(data.timerange.end)
              end.setSeconds(end.getSeconds() - 1); // -1 second in case most recent event ends at midnight
              start.setHours(0,0,0,0) // get start of first day
              end.setHours(0,0,0,0) // get start of last day

              // Initialize picker to the last 2 days of sensor data
              var nearEnd = new Date(end)//.setDate(end.getDate() - 1)
              nearEnd.setDate(nearEnd.getDate() - 1)
              picker.setDateRange(
                nearEnd,
                end,
              );

              // No use looking for data in years outside timerange of sensor data
              picker.setOptions({
                dropdowns: {
                  minYear: start.getFullYear(),
                  maxYear: end.getFullYear(),
                },
              });
            };
          });
        }
      };

      // Set up swiping for the left sidepanel
      var leftSidepanels = document.getElementsByClassName('left-sidepanel');
      document.addEventListener('swiped-right', function(e) {
        if (e.target.classList.contains('sidepanel-container')) {
          for (var i = leftSidepanels.length - 1; i >= 0; i--) {
            leftSidepanels[i].classList.add('sidepanel-show');
          }
        }
      });
      document.addEventListener('swiped-left', function(e) {
        for (var i = leftSidepanels.length - 1; i >= 0; i--) {
          leftSidepanels[i].classList.remove('sidepanel-show');
        }
      });

      // Set up play/pause button for replay
      let toggle = document.querySelector('#replay');
      toggle.addEventListener('click', function(e) {
        e.preventDefault();
        // toggle.classList.toggle('paused');
        if (toggle.classList.contains('playing')) {
          // Pause replay
          console.log("pause replay")
          toggle.classList.remove('playing');
          toggle.classList.add('paused');
        } else if (toggle.classList.contains('stopped')) {
          // Start replay
          console.log("start replay")
          // toggle.classList.remove('paused');
          toggle.classList.remove('stopped');
          toggle.classList.add('playing');
          var beliefTime = new Date(storeStartDate)
          // var beliefTimedelta = 900000
          var beliefTimedelta = 3600000
          var numReplaySteps = Math.ceil((storeEndDate - storeStartDate) / beliefTimedelta)
          queryStartDate = (storeStartDate != null) ? (storeStartDate.toISOString()) : (null)
          queryEndDate = (storeEndDate != null) ? (storeEndDate.toISOString()) : (null)

          $("#spinner").show();
          Promise.all([
            // Fetch time series data
            fetch(sensorPath + '/chart_data/?event_starts_after=' + queryStartDate + '&event_ends_before=' + queryEndDate + '&most_recent_beliefs_only=false', {
              method: "GET",
              headers: {"Content-Type": "application/json"},
            })
            .then(function(response) { return response.json(); }),
          ]).then(function(result) {
            $("#spinner").hide();
            load(result);
          }).catch(console.error);

          const timer = ms => new Promise(res => setTimeout(res, ms))

          async function load (result) {
            var remainingData = result[0]
            var simulatedData = []
            for (var i = 0; i < numReplaySteps + 1; i++) {
              while (document.getElementById('replay').classList.contains('paused') ) {
                await timer(1000);
              }
              if (document.getElementById('replay').classList.contains('stopped') ) {
                break;
              }
              var queryBeliefTime = (beliefTime != null) ? (beliefTime.toISOString()) : (null)
              beliefTime = new Date(beliefTime.getTime() + beliefTimedelta)

              let t0= performance.now();

              // Split of one simulation step of new data from the remaining data
              var newData
              [newData, remainingData] = partition(
                  remainingData,
                  (item) => item.belief_time <= beliefTime.getTime(),
                );

              // Update beliefs in the simulated data given the new data
              const oldLength = simulatedData.length + newData.length;
              simulatedData = updateBeliefs(simulatedData, newData)
              const newLength = simulatedData.length;
              console.log("Removed " + (oldLength - newLength) + " obsolete beliefs")

              let t1= performance.now();

              console.log('Time taken to update data:'+ (t1-t0) +' milliseconds');

              // todo: remove obsolete beliefs and insert most recent new beliefs
              vegaView.change(datasetName, vega.changeset().remove(vega.truthy).insert(simulatedData)).run().finalize();
              
              let t2= performance.now();

              console.log('Time taken to embed data:'+ (t2-t1) +' milliseconds');
              document.getElementById('replay-time').innerHTML = beliefTime
              await timer(25);
            }
            // Stop replay when finished
            console.log("stop replay")
            toggle.classList.remove('playing');
            toggle.classList.add('stopped');
            document.getElementById('replay-time').innerHTML = ''
          }
        } else {
          // Resume replay
          console.log("resume replay")
          toggle.classList.remove('paused');
          toggle.classList.add('playing');
        }
      });

    </script>

    {% block leftsidepanel %} {{ super() }} {% endblock %}

{% endblock %}